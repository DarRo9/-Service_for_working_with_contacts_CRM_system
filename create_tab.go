package main

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	proto "github.com/DarRo9/proto5"
	_ "github.com/go-sql-driver/mysql"
	"google.golang.org/grpc"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"io/ioutil"
	"log"
	"net"
	"net/http"
)

// AutoGenerated - структура для парсинга ответа от AmoCRM в формате json.
type AutoGenerated struct {
	Page  int `json:"_page"`
	Links struct {
		Self struct {
			Href string `json:"href"`
		} `json:"self"`
	} `json:"_links"`
	Embedded struct {
		Contacts []struct {
			ID                 int         `json:"id"`
			Name               string      `json:"name"`
			FirstName          string      `json:"first_name"`
			LastName           string      `json:"last_name"`
			ResponsibleUserID  int         `json:"responsible_user_id"`
			GroupID            int         `json:"group_id"`
			CreatedBy          int         `json:"created_by"`
			UpdatedBy          int         `json:"updated_by"`
			CreatedAt          int         `json:"created_at"`
			UpdatedAt          int         `json:"updated_at"`
			ClosestTaskAt      interface{} `json:"closest_task_at"`
			IsDeleted          bool        `json:"is_deleted"`
			IsUnsorted         bool        `json:"is_unsorted"`
			CustomFieldsValues []struct {
				FieldID   int    `json:"field_id"`
				FieldName string `json:"field_name"`
				FieldCode string `json:"field_code"`
				FieldType string `json:"field_type"`
				Values    []struct {
					Value    string `json:"value"`
					EnumID   int    `json:"enum_id"`
					EnumCode string `json:"enum_code"`
				} `json:"values"`
			} `json:"custom_fields_values"`
			AccountID int `json:"account_id"`
			Links     struct {
				Self struct {
					Href string `json:"href"`
				} `json:"self"`
			} `json:"_links"`
			Embedded struct {
				Tags      []interface{} `json:"tags"`
				Companies []struct {
					ID    int `json:"id"`
					Links struct {
						Self struct {
							Href string `json:"href"`
						} `json:"self"`
					} `json:"_links"`
				} `json:"companies"`
			} `json:"_embedded"`
		} `json:"contacts"`
	} `json:"_embedded"`
}

// Access - структура для получения и хранения информации о токене
type Access struct {
	token string
}

/*
type AccesI interface {
	ContactsInf(string)
}
*/

// Contacts - структура для создания таблицы "contacts"
type Contacts struct {
	gorm.Model
	IDContact int `gorm:"primaryKey"`
	Name      string
	Mail      string
	IDAccount int
}

// Accounts - структура для создания таблицы "accounts"
type Accounts struct {
	gorm.Model
	IDAccount int `gorm:"primaryKey"`
	//ClientSecret string
	//RToken       string
	AToken string
	KeyUni string
}

// AccountsInf - функция для добавления информации об аккаунте
func (at *Access) AccountsInf(atkn string, answerStruct AutoGenerated) {
	var id = 0
	for _, e := range answerStruct.Embedded.Contacts {
		id = e.AccountID
	}
	key := ""
	db.Create(&Accounts{IDAccount: id, AToken: atkn, KeyUni: key})
}

// ContactsInf - функция для добавления информации о контактах
func (at *Access) ContactsInf(answerStruct AutoGenerated) {
	var id_a = 0
	// printing details of
	// decoded data
	for _, e := range answerStruct.Embedded.Contacts {
		id_a = e.AccountID
		n := e.Name
		id := e.ID
		m := ""
		for _, e2 := range e.CustomFieldsValues {
			if e2.FieldCode == "EMAIL" {
				m = e2.Values[0].Value

			}
		}

		if m != "" {
			db.Create(&Contacts{IDContact: id, Name: n, Mail: m, IDAccount: id_a})
		}

	}

}

// Открываем бд
var db, _ = gorm.Open(mysql.Open("steven:here@tcp(127.0.0.1:3306)/fullstack_api"), &gorm.Config{})
var db2, _ = sql.Open("mysql", "steven:here@tcp(127.0.0.1:3306)/fullstack_api")

// Create_Tabs - функция для создания и заполнения таблиц
func Create_Tabs(atoken string) {
	url := "https://new999account999.amocrm.ru/api/v4/contacts"
	at := Access{atoken}
	var bearer = "Bearer " + at.token

	// Create a new request using http
	req, err := http.NewRequest("GET", url, nil)

	// add authorization header to the req
	req.Header.Add("Authorization", bearer)

	// Send req using http Client
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		log.Println("Error on response.\n[ERROR] -", err)
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Println("Error while reading the response bytes:", err)
	}

	var answerStruct AutoGenerated

	err2 := json.Unmarshal([]byte(body), &answerStruct)

	if err2 != nil {

		// if error is not nil
		// print error
		fmt.Println(err)
	}

	db.AutoMigrate(&Accounts{})
	db.AutoMigrate(&Contacts{})

	at.AccountsInf(atoken, answerStruct)
	at.ContactsInf(answerStruct)
}

// InfAboutA - функция для получения информации про аккаунты
func InfAboutA() {
	result2, err2 := db2.Query("Select id_account, a_token, key_uni from accounts")
	if err2 != nil {
		panic(err2)
	}

	defer result2.Close()
	type example2 struct {
		IDAccount int
		AToken    string
		KeyUni    string
	}
	products2 := []example2{}

	for result2.Next() {
		c2 := example2{}
		//err := result.Scan(&c.ID, &c.CreatedAt, &c.UpdatedAt, &c.DeletedAt, &c.IDAmoCRM, &c.Name, &c.Mail)
		err3 := result2.Scan(&c2.IDAccount, &c2.AToken, &c2.KeyUni)

		if err3 != nil {
			fmt.Println(err3)
			continue
		}
		products2 = append(products2, c2)
	}
	for _, c2 := range products2 {
		fmt.Println(c2.IDAccount, " ", c2.AToken, " ", c2.KeyUni)
	}
}
func InfAboutC() {
	result, err := db2.Query("Select id_contact, name, mail, id_account from contacts")
	if err != nil {
		panic(err)
	}

	defer result.Close()
	type example struct {
		IDContact int
		Name      string
		Mail      string
		IDAccount string
	}
	products := []example{}

	for result.Next() {
		c := example{}
		//err := result.Scan(&c.ID, &c.CreatedAt, &c.UpdatedAt, &c.DeletedAt, &c.IDAmoCRM, &c.Name, &c.Mail)
		err := result.Scan(&c.IDContact, &c.Name, &c.Mail, &c.IDAccount)

		if err != nil {
			fmt.Println(err)
			continue
		}
		products = append(products, c)
	}
	for _, c2 := range products {
		fmt.Println(c2.IDContact, " ", c2.Name, " ", c2.Mail, " ", c2.IDAccount)
	}
}

type Server struct {
}

func (s *Server) Do(ctx context.Context, in *proto.Request) (*proto.Response, error) {
	log.Printf("Receive message body from client: %s", in.Message)
	if in.Message == "Удоли" {
		fmt.Print("удалил")
		db.Exec("DELETE FROM contacts;")
		db.Exec("DELETE FROM accounts;")
		db.AutoMigrate(&Accounts{})
		db.AutoMigrate(&Contacts{})
		InfAboutA()
		InfAboutC()
		return &proto.Response{Message: "удалил"}, nil
	}
	return &proto.Response{Message: "не удалил"}, nil

}

func ServerF() {
	fmt.Println("Сервер запущен")

	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", 9000))
	if err != nil {
		log.Fatalf("failed to listen: %v", err)
	}

	var s = Server{}

	grpcServer := grpc.NewServer()

	proto.RegisterDelAccServer(grpcServer, &s)

	if err := grpcServer.Serve(lis); err != nil {
		log.Fatalf("failed to serve: %s", err)
	}

}

func main() {

	defer db2.Close()
	//db2.Query("DROP TABLE contacts;")
	//db2.Query("DROP TABLE accounts;")
	Create_Tabs("eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImp0aSI6IjE1MDM3ZThhYTY3YjZhZTc4NjRmMTA2ODBhMzM3Nzk5YmIzMjNlM2Y4NDgzMjE0OGM5Njk1ODExNDVjY2EzODY1MjA5OTU5OGY1ZWJiMjVkIn0.eyJhdWQiOiI3NjlmNDk5OS04Y2VkLTQ1ZDEtYThkMy1kYTBkYTk4OGU3NzEiLCJqdGkiOiIxNTAzN2U4YWE2N2I2YWU3ODY0ZjEwNjgwYTMzNzc5OWJiMzIzZTNmODQ4MzIxNDhjOTY5NTgxMTQ1Y2NhMzg2NTIwOTk1OThmNWViYjI1ZCIsImlhdCI6MTY5MjI4MDMwNSwibmJmIjoxNjkyMjgwMzA1LCJleHAiOjE2OTIzNjY3MDUsInN1YiI6Ijk5MDc4NDIiLCJncmFudF90eXBlIjoiIiwiYWNjb3VudF9pZCI6MzEyMDk1MTQsImJhc2VfZG9tYWluIjoiYW1vY3JtLnJ1IiwidmVyc2lvbiI6InYyIiwic2NvcGVzIjpbInB1c2hfbm90aWZpY2F0aW9ucyIsImZpbGVzIiwiY3JtIiwiZmlsZXNfZGVsZXRlIiwibm90aWZpY2F0aW9ucyJdfQ.ZMAR5Erop_f-m5004pD4DXlQmAWVrwx0DgXN8oPnnRpXX0c32Y9NH2FS9lpSUAtCShwATmaLtUf-5CUqBLauA-P7i_XgevONjFqHMsZxW3NOs5Ci0UsmRU9vHbg0bIVxf0aWGn9bJBgRu68T3J3CPnPMKnHgrijYagfh9iq0rBvDQd2zk1WgwWiRJZonC_yBqsuN4_EsukXcGNsQCXTxg8De_SAk5LYOLmCRx8H8ODe11q3oiqDfc9kaHDm2q6gvVchHFvyaBjVFsEJ5R18BtG6bsPp0_q8rHCR7KDM_Vdzc3z3djzA3oH3X4ejS6rwbAmWnPw7Mjja0M4QTZDW_vg")

	InfAboutC()
	InfAboutA()
	ServerF()

}
